#include <stdexcept>
#include <vector>

// –î–ª–∏–Ω–∞ –≤—Ö–æ–¥–∞, –µ—Å–ª–∏ –≤—Ö–æ–¥:
// - —á–∏—Å–ª–æ n - log2(n) = log n
// - –æ–¥–Ω–æ–º–µ—Ä–Ω—ã–π –º–∞—Å—Å–∏–≤ - –¥–ª–∏–Ω–∞ –º–∞—Å—Å–∏–≤–∞
// - –¥–≤—É–º–µ—Ä–Ω—ã–π –º–∞—Å—Å–∏–≤ - –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ –º–∞—Å—Å–∏–≤–∞

// –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —á–∏—Å–µ–ª –§–∏–±–æ–Ω–∞—á—á–∏. –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –§–∏–±–æ–Ω–∞—á—á–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –∫–∞–∫:
// a_0 = 0, a_1 = 1, a_k = a_k-1 + a_k-2, –ø—Ä–∏ ùëò ‚â• 2. –î–∞–Ω–æ: n, –≤—ã—á–∏—Å–ª–∏—Ç—å: a_n

// –î–ª–∏–Ω–∞ –≤—Ö–æ–¥–∞ log n
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –≤—Ä–µ–º–µ–Ω–∏ O(2^log n)
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –ø–∞–º—è—Ç–∏ O(1)
uint64_t fibonacci(unsigned int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;

    uint64_t left   = 0;
    uint64_t middle = 1;
    for (int i = 0; i <= n; ++i) {
        unsigned long long cache = middle;
        middle                   = left + middle;
        left                     = cache;
    }
    return middle;
}

// –î–∞–Ω –Ω–µ–≤–æ–∑—Ä–∞—Å—Ç–∞—é—â–∏–π –º–∞—Å—Å–∏–≤ –∏–∑ N —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –ù–∞–π—Ç–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —á–∏—Å–µ–ª
// —Å—Ä–µ–¥–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —ç—Ç–æ–≥–æ –º–∞—Å—Å–∏–≤–∞:
//  a. –î–ª—è –ª—é–±—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
//  b. –ï—Å–ª–∏ –∏–∑–≤–µ—Å—Ç–Ω–æ, —á—Ç–æ –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –º–∞—Å—Å–∏–≤–∞ ‚Äì —á–∏—Å–ª–∞ –æ—Ç 1 –¥–æ k

// a
// –î–ª–∏–Ω–∞ –≤—Ö–æ–¥–∞ N
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –≤—Ä–µ–º–µ–Ω–∏ O(N)
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –ø–∞–º—è—Ç–∏ O(1)
double diffNumsAmount(std::vector<double>& v) {
    if (v.empty()) throw std::invalid_argument("Array cannot be empty");

    double count = 0;
    double prev  = v[0];
    for (size_t i = 0; i < v.size(); ++i) {
        if (v[i] < prev) ++count;
        prev = v[i];
    }
    return count;
}

// b
// –î–ª–∏–Ω–∞ –≤—Ö–æ–¥–∞ N + log k
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –≤—Ä–µ–º–µ–Ω–∏ O(N)
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –ø–∞–º—è—Ç–∏ O(1)
double diffNumsAmount(std::vector<double>& v, int k) {
    // return k; // –µ—Å–ª–∏ –µ—Å—Ç—å —É—Å–ª–æ–≤–∏–µ, —á—Ç–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤—Å–µ —á–∏—Å–ª–∞
    // –∏–∑ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ [1, k] –¢–æ–≥–¥–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç—å –∏ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –∏ –ø–æ –ø–∞–º—è—Ç–∏ - O(1) –í
    // –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –Ω–µ—Ç —Å–º—ã—Å–ª–∞ –º–µ–Ω—è—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º
    if (v.empty()) throw std::invalid_argument("Array cannot be empty");

    double count = 0;
    double prev  = v[0];
    for (size_t i = 0; i < v.size(); ++i) {
        if (v[i] < prev) ++count;
        prev = v[i];
    }
    return count;
}

// –í—ã—á–∏—Å–ª–∏—Ç—å —Å—É–º–º—É 1 / (1!) + 1 / (2!) + ... + 1 / (n!), n - –Ω–∞—Ç—É—Ä–∞–ª—å–Ω–æ–µ

// –î–ª–∏–Ω–∞ –≤—Ö–æ–¥–∞ log n
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –≤—Ä–µ–º–µ–Ω–∏ O(2^log n)
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –ø–∞–º—è—Ç–∏ O(1)
double RowSum(uint8_t n) {
    if (n == 0)
        throw std::invalid_argument(
            "Can not calculate factorial of negative number");
    if (n == 1) return 1;
    double sum = 1;
    for (uint8_t i = 2; i < n; ++i) {
        sum += sum / i;
    }
    return sum;
}

// –í –º–∞—Å—Å–∏–≤–µ a[1], ... , a[n] –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è –ø–æ –æ–¥–Ω–æ–º—É —Ä–∞–∑—É –≤—Å–µ —á–∏—Å–ª–∞ –æ—Ç 0 –¥–æ ùëõ,
// –∫—Ä–æ–º–µ –æ–¥–Ω–æ–≥–æ. –ù–∞–π—Ç–∏ –ø—Ä–æ–ø—É—â–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ (—Å –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–π –¥–æ–ø. –ø–∞–º—è—Ç—å—é).

// –î–ª–∏–Ω–∞ –≤—Ö–æ–¥–∞ n
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –≤—Ä–µ–º–µ–Ω–∏ O(n)
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –ø–∞–º—è—Ç–∏ O(1)
uint32_t whichNumIsMissing(std::vector<uint32_t>& v, uint32_t n) {
    uint64_t sum = 0;
    for (size_t i = 0; i < v.size(); ++i) {
        sum += v[i];
    }
    // (a_1 + a_n) / 2 * n - —Å—É–º–º–∞ –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–≥—Ä–µ—Å—Å–∏–∏
    return n * n / 2 - sum;
}

// –î–∞–Ω –¥–≤—É–º–µ—Ä–Ω—ã–π –º–∞—Å—Å–∏–≤ x: array[n x n], —Ç–∞–∫–æ–π, —á—Ç–æ: x[i][j] <= x[i][j + 1],
// x[i][j] <= x[i + 1][j], –∏ —á–∏—Å–ª–æ a. –¢—Ä–µ–±—É–µ—Ç—Å—è –≤—ã—è—Å–Ω–∏—Ç—å, –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è –ª–∏ a –≤
// –¥–∞–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ.

// –î–ª–∏–Ω–∞ –≤—Ö–æ–¥–∞ n^2
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –≤—Ä–µ–º–µ–Ω–∏ O(n^2)
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –ø–∞–º—è—Ç–∏ O(1)
bool isContaining(std::vector<std::vector<double>>& v, double a) {
    if (v.empty()) return false;

    size_t lastCol = v[0].size();
    size_t lastStr = v.size();
    for (size_t i = 0; i < lastStr; ++i) {
        if (v[i][0] > a) {
            lastStr = i;
        }
        for (size_t j = 0; j < lastCol; ++j) {
            if (v[i][j] == a) return true;
            if (v[i][j] > a) {
                lastCol = j;
            }
        }
    }
    return false;
}

// –†–∞–∑—Ä–∞–±–æ—Ç–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è —Å—É–¥–æ–∫—É
// (—Ä–∞–∑–º–µ—Ä N^2 x N^2)

// –î–ª–∏–Ω–∞ –≤—Ö–æ–¥–∞ N^4
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –≤—Ä–µ–º–µ–Ω–∏ O(N^4)
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –ø–∞–º—è—Ç–∏ O(1)
bool sudokuFilledCorrected(std::vector<std::vector<uint32_t>>& v) {
    // (a_1 + a_n) / 2 * n - —Å—É–º–º–∞ –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–≥—Ä–µ—Å—Å–∏–∏
    const uint64_t sumThatShouldBe = (1 + v.size()) * v.size() / 2;
    for (size_t i = 0; i < v.size(); ++i) {
        uint64_t strSum = 0;
        for (size_t j = 0; j < v.size(); ++j) {
            if (v[i][j] == 0) return false;
            strSum += v[i][j];
            if (strSum > sumThatShouldBe) return false;
        }
        if (strSum != sumThatShouldBe) return false;
    }

    // –ú–æ–∂–Ω–æ –±—ã–ª–æ –±—ã –∏—Å–∫–ª—é—á–∏—Ç—å —Ü–∏–∫–ª –Ω–∏–∂–µ, –Ω–æ –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ—Ç—Ä–µ–±–æ–≤–∞–ª—Å—è –±—ã –º–∞—Å—Å–∏–≤
    // vector<uint64_t> —Ä–∞–∑–º–µ—Ä–∞ N^2, —Ö—Ä–∞–Ω–∏–≤—à–∏–π –±—ã —Å—É–º–º—ã —Å—Ç–æ–ª–±—Ü–æ–≤, —á—Ç–æ –∏–∑–º–µ–Ω–∏–ª–æ
    // –±—ã —Å–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –ø–∞–º—è—Ç–∏ –¥–æ O(sqrt(N^4)), –∞ —Å–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –¥–æ
    // O(sqrt(N^4))
    for (size_t j = 0; j < v.size(); ++j) {
        uint64_t colSum = 0;
        for (size_t i = 0; i < v.size(); ++i) {
            if (v[j][i] == 0) return false;
            colSum += v[j][i];
            if (colSum > sumThatShouldBe) return false;
        }
        if (colSum != sumThatShouldBe) return false;
    }

    return true;
}

// –î–∞–Ω –º–∞—Å—Å–∏–≤ —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª nums. –ù–µ–æ–±—Ö–æ–¥–∏–º–æ –≤–µ—Ä–Ω—É—Ç—å –º–∞—Å—Å–∏–≤ answer, –≥–¥–µ answer[i]
// —Ä–∞–≤–Ω–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—é –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞, –∫—Ä–æ–º–µ nums[i]. –ó–∞–ø—Ä–µ—â–∞–µ—Ç—Å—è
// –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–µ–ª–µ–Ω–∏—è

// –î–ª–∏–Ω–∞ –≤—Ö–æ–¥–∞ n
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –≤—Ä–µ–º–µ–Ω–∏ O(n^2)
// –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ –ø–∞–º—è—Ç–∏ O(n)
std::vector<uint64_t> compositionExceptSelf(std::vector<uint16_t>& nums) {
    std::vector<uint64_t> answer(nums.size(), 1);

    for (size_t i = 0; i < nums.size(); ++i) {
        for (size_t j = 0; j < answer.size(); ++j) {
            if (j == i) continue;
            answer[j] *= nums[i];
        }
    }

    return answer;
}
